-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Calculate the edit distance between two foldables.
--   
--   A package to determine the edit distance between two <a>Foldable</a>s.
--   These are converted to lists, and the Levenshtein distance determine
--   how many additions, removals and changes are necessary to change the
--   first list into the second list.
@package levenshtein
@version 0.2.1.0


-- | The <i>Levenshtein distance</i> is the <i>minimal</i> number of
--   additions, removals, and updates one has to make to convert one list
--   of items into another list of items. In this module we provide some
--   functions that makes it convenient to calculate the distance and the
--   sequence of <a>Edit</a>s, and furthermore ways to alter the score for
--   an addition, removal, edit that can depend on what item is modified.
module Data.Foldable.Levenshtein

-- | A function to determine the <i>Levenshtein distance</i> by specifying
--   the cost functions of adding, removing and editing characters. This
--   function returns the sum of the costs to transform the first
--   <a>Foldable</a> (as list) into the second <a>Foldable</a> (as list).
--   The <a>(==)</a> function is used to determine if two items are
--   equivalent.
genericLevenshteinDistance :: (Foldable f, Foldable g, Eq a, Num b, Ord b) => (a -> b) -> (a -> b) -> (a -> a -> b) -> f a -> g a -> b

-- | A function to determine the <i>Levenshtein distance</i> by specifying
--   the cost functions of adding, removing and editing characters. This
--   function returns the sum of the costs to transform the first
--   <a>Foldable</a> (as list) into the second <a>Foldable</a> (as list).
--   The first parameter is an equivalence relation to determine if two
--   items are considered equivalent.
genericLevenshteinDistance' :: (Foldable f, Foldable g, Num b, Ord b) => (a -> a -> Bool) -> (a -> b) -> (a -> b) -> (a -> a -> b) -> f a -> g a -> b

-- | Calculate the Levenshtein distance with the given <a>EditScore</a>
--   object that determine how costly each edit is. The function determines
--   the minimal score with <a>Add</a>, <a>Rem</a>, <a>Copy</a> and
--   <a>Swap</a> edits. We determine if two items are the same with the
--   <a>Eq</a> instance for the item type.
genericLevenshteinDistanceWithScore :: (Foldable f, Foldable g, Eq a, Num b, Ord b) => EditScore a b -> f a -> g a -> b

-- | Calculate the Levenshtein distance with the given equivalence
--   relation, and the given <a>EditScore</a> object that determine how
--   costly each edit is. The function determines the minimal score with
--   <a>Add</a>, <a>Rem</a>, <a>Copy</a> and <a>Swap</a> edits.
genericLevenshteinDistanceWithScore' :: (Foldable f, Foldable g, Num b, Ord b) => (a -> a -> Bool) -> EditScore a b -> f a -> g a -> b

-- | Determine the edit distance where an addition, removal, and change all
--   count as one, and where the <a>Eq</a> instance is used to determine
--   whether two items are equivalent, this is for example useful for
--   case-insensitve matching.
levenshteinDistance :: (Foldable f, Foldable g, Eq a, Num b, Ord b) => f a -> g a -> b

-- | Determine the edit distance to transform the first <a>Foldable</a> (as
--   list) into a second <a>Foldable</a> (as list). Add, remove and
--   swapping items all count as one edit distance. The first parameter is
--   an equivalence relation that is used to determine if two items are
--   considered equivalent.
levenshteinDistance' :: (Foldable f, Foldable g, Num b, Ord b) => (a -> a -> Bool) -> f a -> g a -> b

-- | A function to determine the <i>Levenshtein distance</i> together with
--   a list of <a>Edit</a>s to apply to convert the first <a>Foldable</a>
--   (as list) into the second item (as list) The cost functions of adding,
--   removing and editing characters will be used to minimize the total
--   edit distance. The <a>(==)</a> function is used to determine if two
--   items of the <a>Foldable</a>s are considered equivalent.
genericLevenshtein :: (Foldable f, Foldable g, Eq a, Num b, Ord b) => (a -> b) -> (a -> b) -> (a -> a -> b) -> f a -> g a -> (b, Edits a)

-- | A function to determine the <i>Levenshtein distance</i> together with
--   a list of <a>Edit</a>s to apply to convert the first <a>Foldable</a>
--   (as list) into the second item (as list) The cost functions of adding,
--   removing and editing characters will be used to minimize the total
--   edit distance. The first parameter is an equivalence relation that is
--   used to determine if two items of the <a>Foldable</a>s are considered
--   equivalent.
genericLevenshtein' :: (Foldable f, Foldable g, Num b, Ord b) => (a -> a -> Bool) -> (a -> b) -> (a -> b) -> (a -> a -> b) -> f a -> g a -> (b, Edits a)

-- | Calculate the Levenshtein distance and the modifications with the
--   given <a>EditScore</a> object that determine how costly each edit is.
--   The function determines the minimal score with <a>Add</a>, <a>Rem</a>,
--   <a>Copy</a> and <a>Swap</a> edits. The <a>Eq</a> instance of the
--   elements is used to determine if two items are equivalent.
genericLevenshteinWithScore :: (Foldable f, Foldable g, Eq a, Num b, Ord b) => EditScore a b -> f a -> g a -> (b, Edits a)

-- | Calculate the Levenshtein distance and the modifications with the
--   given equivalence relation, and the given <a>EditScore</a> object that
--   determine how costly each edit is. The function determines the minimal
--   score with <a>Add</a>, <a>Rem</a>, <a>Copy</a> and <a>Swap</a> edits.
genericLevenshteinWithScore' :: (Foldable f, Foldable g, Num b, Ord b) => (a -> a -> Bool) -> EditScore a b -> f a -> g a -> (b, Edits a)

-- | Determine the edit distance together with the steps to transform the
--   first <a>Foldable</a> (as list) into a second <a>Foldable</a> (as
--   list). Add, remove and swapping items all count as one edit distance.
levenshtein :: (Foldable f, Foldable g, Eq a, Num b, Ord b) => f a -> g a -> (b, Edits a)

-- | Determine the edit distance together with the steps to transform the
--   first <a>Foldable</a> (as list) into a second <a>Foldable</a> (as
--   list). Add, remove and swapping items all count as one edit distance.
--   The first parameter is a function to determine if two items are of the
--   <a>Foldable</a>s are considered equivalent.
levenshtein' :: (Foldable f, Foldable g, Num b, Ord b) => (a -> a -> Bool) -> f a -> g a -> (b, Edits a)

-- | A function to determine the <i>Levenshtein distance</i> together with
--   a list of <a>Edit</a>s to apply to convert the first <a>Foldable</a>
--   (as list) into the second item (as list) in <i>reversed</i> order. The
--   cost functions of adding, removing and editing characters will be used
--   to minimize the total edit distance. The <a>(==)</a> function is used
--   to determine if two items of the <a>Foldable</a>s are considered
--   equivalent.
genericReversedLevenshtein :: (Foldable f, Foldable g, Eq a, Num b, Ord b) => (a -> b) -> (a -> b) -> (a -> a -> b) -> f a -> g a -> (b, Edits a)

-- | A function to determine the <i>Levenshtein distance</i> together with
--   a list of <a>Edit</a>s to apply to convert the first <a>Foldable</a>
--   (as list) into the second item (as list) in <i>reversed</i> order. The
--   cost functions of adding, removing and editing characters will be used
--   to minimize the total edit distance. The first parameter is an
--   equivalence relation that is used to determine if two items of the
--   <a>Foldable</a>s are considered equivalent.
genericReversedLevenshtein' :: (Foldable f, Foldable g, Num b, Ord b) => (a -> a -> Bool) -> (a -> b) -> (a -> b) -> (a -> a -> b) -> f a -> g a -> (b, Edits a)

-- | Calculate the Levenshtein distance and the modifications with the
--   given <a>EditScore</a> object that determine how costly each edit is.
--   The function determines the minimal score with <a>Add</a>, <a>Rem</a>,
--   <a>Copy</a> and <a>Swap</a> edits. The <a>Eq</a> instance of the items
--   will determine the equivalence relation.
genericReversedLevenshteinWithScore :: (Foldable f, Foldable g, Eq a, Num b, Ord b) => EditScore a b -> f a -> g a -> (b, Edits a)

-- | Calculate the Levenshtein distance and the modifications with the
--   given equivalence relation, and the given <a>EditScore</a> object that
--   determine how costly each edit is. The function determines the minimal
--   score with <a>Add</a>, <a>Rem</a>, <a>Copy</a> and <a>Swap</a> edits.
genericReversedLevenshteinWithScore' :: (Foldable f, Foldable g, Num b, Ord b) => (a -> a -> Bool) -> EditScore a b -> f a -> g a -> (b, Edits a)

-- | Determine the edit distance together with the steps to transform the
--   first <a>Foldable</a> (as list) into a second <a>Foldable</a> (as
--   list). Add, remove and swapping items all count as one edit distance.
--   The equality function <a>(==)</a> is used to determine if two items
--   are equivalent.
reversedLevenshtein :: (Foldable f, Foldable g, Eq a, Num b, Ord b) => f a -> g a -> (b, Edits a)

-- | Determine the edit distance together with the steps to transform the
--   first <a>Foldable</a> (as list) into a second <a>Foldable</a> (as
--   list) in <i>reversed</i> order. Add, remove and swapping items all
--   count as one edit distance. The given equality function is used to
--   determine if two items are equivalent.
reversedLevenshtein' :: (Foldable f, Foldable g, Num b, Ord b) => (a -> a -> Bool) -> f a -> g a -> (b, Edits a)

-- | A data type that is used to list how to edit a sequence to form
--   another sequence.
data Edit a

-- | We add the given element to the sequence.
Add :: a -> Edit a

-- | We remove the given element to the sequence.
Rem :: a -> Edit a

-- | We copy an element from the sequence, this basically act as a
--   <i>no-op</i>.
Copy :: a -> Edit a

-- | We modify the given first item into the second item, this thus denotes
--   a replacement.
Swap :: a -> a -> Edit a

-- | A type alias for a <i>list</i> of <a>Edit</a>s.
type Edits a = [Edit a]

-- | Apply the given list of <a>Edit</a>s to the given list. If the
--   <a>Edit</a>s make sense, it returns the result wrapped in a
--   <a>Just</a>, if a check with the item that is removed/replaced fails,
--   the function will return <a>Nothing</a>.
applyEdits :: Eq a => Edits a -> [a] -> Maybe [a]

-- | A data type that provides information about how costly a certain edit
--   is. One can make use of this data type to change the cost functions in
--   an effective way. The <a>EditScore</a> scales linear, this means that
--   if we double all the costs, the minimal edit cost will also double.
data EditScore a b

-- | Determine the cost of a given <a>Edit</a> as described with the given
--   <a>EditScore</a> object.
editCost :: Num b => EditScore a b -> Edit a -> b

-- | Determine the cost of the given sequence of <a>Edit</a>s with the
--   given <a>EditScore</a> object that determines the cost for each edit.
--   The sum of the <a>Edit</a>s is returned.
editsCost :: (Foldable f, Num b) => EditScore a b -> f (Edit a) -> b

-- | A function to construct an <a>EditScore</a> object where the cost of
--   adding, removing, replacing and transposing all have the same given
--   cost.
constantEditScore :: b -> EditScore a b
instance GHC.Generics.Generic1 (Data.Foldable.Levenshtein.EditScore a)
instance GHC.Generics.Generic (Data.Foldable.Levenshtein.EditScore a b)
instance GHC.Base.Functor (Data.Foldable.Levenshtein.EditScore a)
instance Data.Traversable.Traversable Data.Foldable.Levenshtein.Edit
instance GHC.Show.Show a => GHC.Show.Show (Data.Foldable.Levenshtein.Edit a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Foldable.Levenshtein.Edit a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Foldable.Levenshtein.Edit a)
instance GHC.Generics.Generic1 Data.Foldable.Levenshtein.Edit
instance GHC.Generics.Generic (Data.Foldable.Levenshtein.Edit a)
instance GHC.Base.Functor Data.Foldable.Levenshtein.Edit
instance Data.Foldable.Foldable Data.Foldable.Levenshtein.Edit
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Foldable.Levenshtein.Edit a)
instance Data.Data.Data a => Data.Data.Data (Data.Foldable.Levenshtein.Edit a)
instance Test.QuickCheck.Arbitrary.Arbitrary1 Data.Foldable.Levenshtein.Edit
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Data.Foldable.Levenshtein.Edit a)
instance Data.Binary.Class.Binary a => Data.Binary.Class.Binary (Data.Foldable.Levenshtein.Edit a)
instance Data.Functor.Classes.Eq1 Data.Foldable.Levenshtein.Edit
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Data.Foldable.Levenshtein.Edit a)
instance Data.Hashable.Class.Hashable1 Data.Foldable.Levenshtein.Edit
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Foldable.Levenshtein.Edit a)
instance Control.DeepSeq.NFData1 Data.Foldable.Levenshtein.Edit
instance Data.Functor.Classes.Ord1 Data.Foldable.Levenshtein.Edit
instance GHC.Num.Num b => Data.Default.Class.Default (Data.Foldable.Levenshtein.EditScore a b)
